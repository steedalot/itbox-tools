#!/usr/bin/env python3
"""
catalogctl - Container Catalog Management Tool
Version 0.1

Manages the IT.Box container catalog server. Validates and imports
container definitions into the catalog for distribution to IT.Boxes.

Usage:
    sudo catalogctl install                 # Initial setup
    catalogctl validate <file.yaml>         # Validate container definition
    sudo catalogctl import <file.yaml>      # Import container to catalog
    sudo catalogctl remove <container>      # Remove container from catalog
    catalogctl list                         # List catalog containers
    catalogctl export <container>           # Export container definition

Author: IT.Box Project
License: MIT
"""

import sys
import os
import subprocess
import json
import shutil
from pathlib import Path
from datetime import datetime
from urllib.request import urlopen
from urllib.error import URLError

try:
    import yaml
except ImportError:
    print("Error: PyYAML not installed. Run: sudo apt install python3-yaml")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("Error: requests not installed. Run: sudo apt install python3-requests")
    sys.exit(1)


# ============================================================================
# CONSTANTS
# ============================================================================

VERSION = "2.0.0"

# Default paths
DEFAULT_BASE_DIR = Path("/opt/kibox/containers")
DEFAULT_CONFIG_DIR = Path("/opt/kibox/config/catalogctl")

# Files
CATALOG_FILE = "catalog.yaml"
CONTAINERS_DIR = "containers"

# NGINX template
NGINX_CONF_TEMPLATE = """# nginx Configuration for Container Catalog Server
# Generated by catalogctl {version}

server {{
    listen 80;
    listen [::]:80;

    server_name {domain};

    # Root directory for container catalog
    root /opt/kibox;

    # Access and error logs
    access_log /var/log/nginx/{domain}.access.log;
    error_log /var/log/nginx/{domain}.error.log;

    # Container catalog location
    location /containers {{
        alias /opt/kibox/containers;

        # Enable directory listing
        autoindex on;
        autoindex_exact_size off;
        autoindex_localtime on;

        # CORS headers for cross-origin requests from IT.Boxes
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Origin, Content-Type, Accept' always;

        # Handle preflight requests
        if ($request_method = 'OPTIONS') {{
            return 204;
        }}

        # YAML files
        location ~ \\.yaml$ {{
            add_header Content-Type "application/x-yaml; charset=utf-8";
            add_header 'Access-Control-Allow-Origin' '*' always;
        }}

        # Markdown files
        location ~ \\.md$ {{
            add_header Content-Type "text/markdown; charset=utf-8";
            add_header 'Access-Control-Allow-Origin' '*' always;
        }}

        # Default index
        index catalog.yaml README.md;
    }}

    # Health check endpoint
    location /health {{
        access_log off;
        return 200 "OK\\n";
        add_header Content-Type text/plain;
    }}

    # Root redirect to containers
    location = / {{
        return 301 /containers/;
    }}
}}
"""


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def ensure_root():
    """Ensure script is run as root"""
    if os.geteuid() != 0:
        print("Error: This command must be run as root (use sudo)")
        sys.exit(1)


def load_yaml(file_path):
    """Load YAML file"""
    try:
        with open(file_path, 'r') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        return None
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return None


def save_yaml(data, file_path):
    """Save YAML file"""
    try:
        file_path.parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'w') as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
    except Exception as e:
        print(f"Error saving YAML file {file_path}: {e}")
        sys.exit(1)


def print_header(text):
    """Print formatted header"""
    print(f"\n{'=' * 60}")
    print(f"  {text}")
    print(f"{'=' * 60}\n")


def print_success(text):
    """Print success message"""
    print(f"‚úÖ {text}")


def print_error(text):
    """Print error message"""
    print(f"‚ùå {text}")


def print_warning(text):
    """Print warning message"""
    print(f"‚ö†Ô∏è  {text}")


def print_info(text):
    """Print info message"""
    print(f"üí° {text}")


def print_step(text):
    """Print step message"""
    print(f"‚ñ∏ {text}...", end='', flush=True)


def print_done():
    """Print done marker"""
    print(" ‚úì")


def print_fail():
    """Print fail marker"""
    print(" ‚úó")


# ============================================================================
# CATALOG MANAGER
# ============================================================================

class CatalogManager:
    """Manages container catalog on server"""

    def __init__(self, base_dir=None, config_dir=None):
        self.base_dir = Path(base_dir or DEFAULT_BASE_DIR)
        self.config_dir = Path(config_dir or DEFAULT_CONFIG_DIR)

        self.catalog_file = self.base_dir / CATALOG_FILE
        self.containers_dir = self.base_dir / CONTAINERS_DIR

    def load_catalog(self):
        """Load catalog.yaml"""
        catalog = load_yaml(self.catalog_file)
        if not catalog:
            print_error(f"Catalog not found at {self.catalog_file}")
            print_info("Run 'sudo catalogctl install' first")
            sys.exit(1)
        return catalog

    def save_catalog(self, catalog):
        """Save catalog.yaml"""
        catalog['updated'] = datetime.now().isoformat()
        save_yaml(catalog, self.catalog_file)

    def validate_container_def(self, container_def, file_path):
        """Validate container definition"""
        errors = []
        warnings = []

        # Required fields
        required_fields = ['id', 'name', 'version', 'description', 'category', 'image', 'ports', 'volumes']
        for field in required_fields:
            if field not in container_def:
                errors.append(f"Missing required field: {field}")

        # Image structure
        if 'image' in container_def:
            if not isinstance(container_def['image'], dict):
                errors.append("'image' must be an object with 'name' and 'tag'")
            elif 'name' not in container_def['image'] or 'tag' not in container_def['image']:
                errors.append("'image' must have 'name' and 'tag' fields")

        # Ports structure
        if 'ports' in container_def:
            if not isinstance(container_def['ports'], list):
                errors.append("'ports' must be an array")
            else:
                for i, port in enumerate(container_def['ports']):
                    if not all(k in port for k in ['host', 'container', 'protocol', 'description']):
                        errors.append(f"Port {i}: Missing required fields (host, container, protocol, description)")
                    if 'protocol' in port and port['protocol'] not in ['tcp', 'udp']:
                        errors.append(f"Port {i}: protocol must be 'tcp' or 'udp'")

        # Volumes structure
        if 'volumes' in container_def:
            if not isinstance(container_def['volumes'], list):
                errors.append("'volumes' must be an array")
            else:
                for i, vol in enumerate(container_def['volumes']):
                    if not all(k in vol for k in ['host', 'container', 'description']):
                        errors.append(f"Volume {i}: Missing required fields (host, container, description)")

        # Check environment variables
        if 'environment' in container_def:
            if not isinstance(container_def['environment'], list):
                errors.append("'environment' must be an array")

        # Check secrets
        if 'secrets' in container_def:
            if not isinstance(container_def['secrets'], list):
                errors.append("'secrets' must be an array")
            else:
                for i, secret in enumerate(container_def['secrets']):
                    if not all(k in secret for k in ['key', 'description', 'required']):
                        warnings.append(f"Secret {i}: Should have 'key', 'description', 'required' fields")

        # Check global_env (optional field)
        if 'global_env' in container_def:
            global_env_errors = self.validate_global_env(container_def['global_env'])
            errors.extend(global_env_errors)

        # Check prompts (optional field)
        if 'prompts' in container_def:
            prompts_errors = self.validate_prompts(container_def['prompts'])
            errors.extend(prompts_errors)

        return errors, warnings

    def validate_global_env(self, global_env):
        """Validate global_env field structure"""
        errors = []

        if not isinstance(global_env, list):
            errors.append("'global_env' must be an array")
            return errors

        for i, item in enumerate(global_env):
            if not isinstance(item, dict):
                errors.append(f"global_env item {i}: must be an object")
                continue

            # Required fields
            if 'key' not in item:
                errors.append(f"global_env item {i}: missing 'key' field")
            if 'description' not in item:
                errors.append(f"global_env item {i}: missing 'description' field")
            if 'required' not in item:
                errors.append(f"global_env item {i}: missing 'required' field")

            # Validate types
            if 'required' in item and not isinstance(item['required'], bool):
                errors.append(f"global_env item {i}: 'required' must be boolean")

            # Optional default field
            if 'default' in item and not isinstance(item['default'], str):
                errors.append(f"global_env item {i}: 'default' must be string")

        return errors

    def validate_prompts(self, prompts):
        """Validate prompts field structure"""
        errors = []

        if not isinstance(prompts, list):
            errors.append("'prompts' must be an array")
            return errors

        for i, item in enumerate(prompts):
            if not isinstance(item, dict):
                errors.append(f"prompts item {i}: must be an object")
                continue

            # Required fields
            if 'key' not in item:
                errors.append(f"prompts item {i}: missing 'key' field")
            if 'question' not in item:
                errors.append(f"prompts item {i}: missing 'question' field")

            # Optional fields - validate if present
            if 'default' in item and not isinstance(item['default'], str):
                errors.append(f"prompts item {i}: 'default' must be string")

            if 'description' in item and not isinstance(item['description'], str):
                errors.append(f"prompts item {i}: 'description' must be string")

            if 'options' in item:
                if not isinstance(item['options'], list):
                    errors.append(f"prompts item {i}: 'options' must be array")
                elif len(item['options']) == 0:
                    errors.append(f"prompts item {i}: 'options' cannot be empty")

            if 'validate' in item:
                valid_validators = ['int', 'float', 'url']
                if item['validate'] not in valid_validators:
                    errors.append(f"prompts item {i}: 'validate' must be one of {valid_validators}")

        return errors

    def check_port_conflicts(self, container_def):
        """Check if ports are already used in catalog"""
        catalog = self.load_catalog()
        conflicts = []

        for port_info in container_def.get('ports', []):
            port = port_info['host']
            protocol = port_info['protocol']

            # Check against all containers in catalog
            for cat_container in catalog.get('containers', []):
                cat_id = cat_container['id']

                # Skip if same container (for updates)
                if cat_id == container_def['id']:
                    continue

                # Load container definition
                cat_def_file = self.containers_dir / f"{cat_id}.yaml"
                if not cat_def_file.exists():
                    continue

                cat_def = load_yaml(cat_def_file)
                if not cat_def:
                    continue

                # Check ports
                for cat_port in cat_def.get('ports', []):
                    if cat_port['host'] == port and cat_port['protocol'] == protocol:
                        conflicts.append({
                            'port': port,
                            'protocol': protocol,
                            'container': cat_id
                        })

        return conflicts

    def check_dependencies(self, container_def):
        """Check if dependencies exist in catalog"""
        catalog = self.load_catalog()
        missing = []

        depends_on = container_def.get('depends_on', [])
        if not depends_on:
            return missing

        existing_ids = [c['id'] for c in catalog.get('containers', [])]

        for dep in depends_on:
            if dep not in existing_ids:
                missing.append(dep)

        return missing

    def validate_docker_image(self, image_name, image_tag):
        """Check if Docker image exists on Docker Hub"""
        # For MVP, just check format
        # TODO: Actual Docker Hub API call
        if not image_name or not image_tag:
            return False
        return True


# ============================================================================
# COMMANDS
# ============================================================================

def cmd_install(args):
    """Install catalogctl and create directory structure"""
    ensure_root()

    # Check if we need to install the script itself
    script_path = Path(__file__).resolve()
    target_path = Path("/usr/local/bin/catalogctl")

    if script_path != target_path:
        print_header("Installing catalogctl Script")
        print_step(f"Copying to /usr/local/bin/catalogctl")
        shutil.copy(script_path, target_path)
        print_done()

        print_step("Making executable")
        target_path.chmod(0o755)
        print_done()

        print_success("catalogctl script installed to /usr/local/bin/")
        print()

    print_header("catalogctl Installation")

    manager = CatalogManager()

    # Get domain
    print("Container Catalog Configuration:")
    domain = input("Domain [apps.kibox.online]: ").strip()
    if not domain:
        domain = "apps.kibox.online"
    print(f"Using: {domain}\n")

    # Create directories
    print_step("Creating directories")
    manager.base_dir.mkdir(parents=True, exist_ok=True)
    manager.containers_dir.mkdir(parents=True, exist_ok=True)
    manager.config_dir.mkdir(parents=True, exist_ok=True)
    print_done()

    # Initialize catalog.yaml
    print_step("Creating catalog.yaml")

    catalog = {
        'version': '1.0',
        'updated': datetime.now().isoformat(),
        'categories': [
            {'id': 'infrastructure', 'name': 'Infrastruktur', 'icon': 'üèóÔ∏è'},
            {'id': 'development', 'name': 'Entwicklung', 'icon': 'üíª'},
            {'id': 'education', 'name': 'P√§dagogische Apps', 'icon': 'üìö'},
            {'id': 'games', 'name': 'Game-Server', 'icon': 'üéÆ'}
        ],
        'containers': []
    }

    manager.save_catalog(catalog)
    print_done()

    # Generate nginx config
    print_step("Generating nginx config")
    nginx_conf = NGINX_CONF_TEMPLATE.format(
        version=VERSION,
        domain=domain
    )

    nginx_file = manager.config_dir / f"{domain}.conf"
    nginx_file.write_text(nginx_conf)
    print_done()

    # Set permissions
    print_step("Setting permissions")
    subprocess.run(['chown', '-R', 'www-data:www-data', str(manager.base_dir)], check=False)
    print_done()

    # Install nginx config
    print()
    print_step("Installing nginx configuration")
    nginx_available = Path(f"/etc/nginx/sites-available/{domain}.conf")
    nginx_enabled = Path(f"/etc/nginx/sites-enabled/{domain}.conf")

    try:
        # Copy to sites-available
        shutil.copy(nginx_file, nginx_available)

        # Create symlink in sites-enabled
        if nginx_enabled.exists() or nginx_enabled.is_symlink():
            nginx_enabled.unlink()
        nginx_enabled.symlink_to(nginx_available)

        print_done()
    except Exception as e:
        print_fail()
        print_error(f"Failed to install nginx config: {e}")
        sys.exit(1)

    # Test nginx configuration
    print_step("Testing nginx configuration")
    result = subprocess.run(['nginx', '-t'], capture_output=True, text=True)
    if result.returncode != 0:
        print_fail()
        print_error("nginx configuration test failed:")
        print(result.stderr)
        sys.exit(1)
    print_done()

    # Reload nginx
    print_step("Reloading nginx")
    result = subprocess.run(['systemctl', 'reload', 'nginx'], capture_output=True, text=True)
    if result.returncode != 0:
        print_fail()
        print_error("Failed to reload nginx:")
        print(result.stderr)
        sys.exit(1)
    print_done()

    print_success("catalogctl installed successfully!")
    print()

    # Ask about SSL
    print("SSL Certificate Setup:")
    response = input(f"Setup SSL certificate with certbot for {domain}? [Y/n]: ").strip().lower()

    if response in ['', 'y', 'yes']:
        print()
        print_step(f"Running certbot for {domain}")
        print()

        # Run certbot interactively
        result = subprocess.run(['certbot', '--nginx', '-d', domain])

        if result.returncode == 0:
            print()
            print_success(f"SSL certificate installed for {domain}!")
            print()
            print(f"üì¶ Catalog available at: https://{domain}/containers")
        else:
            print()
            print_warning("SSL setup failed or was cancelled")
            print(f"üì¶ Catalog available at: http://{domain}/containers (HTTP only)")
            print_info(f"Run manually later: sudo certbot --nginx -d {domain}")
    else:
        print()
        print(f"üì¶ Catalog available at: http://{domain}/containers (HTTP only)")
        print_info(f"Setup SSL later: sudo certbot --nginx -d {domain}")

    print()
    print_info("Next steps:")
    print(f"  1. Import containers: sudo catalogctl import <file.yaml>")
    print(f"  2. View catalog: catalogctl list")


def cmd_validate(args):
    """Validate container definition without importing"""
    if not args.file:
        print_error("Usage: catalogctl validate <file.yaml>")
        sys.exit(1)

    yaml_file = Path(args.file)
    if not yaml_file.exists():
        print_error(f"File not found: {yaml_file}")
        sys.exit(1)

    print_header(f"Validating {yaml_file.name}")

    manager = CatalogManager()

    # Load YAML
    print_step("Loading YAML")
    container_def = load_yaml(yaml_file)
    if not container_def:
        print_fail()
        print_error("Invalid YAML syntax")
        sys.exit(1)
    print_done()

    # Validate structure
    print_step("Validating schema")
    errors, warnings = manager.validate_container_def(container_def, yaml_file)

    if errors:
        print_fail()
        print()
        for error in errors:
            print_error(error)
        sys.exit(1)
    print_done()

    if warnings:
        print()
        for warning in warnings:
            print_warning(warning)

    # Check Docker image
    print_step("Checking Docker image")
    if 'image' in container_def:
        valid = manager.validate_docker_image(
            container_def['image'].get('name'),
            container_def['image'].get('tag')
        )
        if not valid:
            print_fail()
            print_warning("Could not validate Docker image")
        else:
            print_done()

    # Check port conflicts
    print()
    print("Checking port conflicts:")
    conflicts = manager.check_port_conflicts(container_def)

    if conflicts:
        for conflict in conflicts:
            print_error(f"  Port {conflict['port']}/{conflict['protocol']} already used by {conflict['container']}")
        sys.exit(1)
    else:
        for port_info in container_def.get('ports', []):
            print(f"  ‚úì {port_info['host']}/{port_info['protocol']} available")

    # Check dependencies
    missing_deps = manager.check_dependencies(container_def)
    if missing_deps:
        print()
        print("Dependencies:")
        for dep in missing_deps:
            print_warning(f"  {dep} not in catalog (will need to be added first)")

    print()
    print_success("Validation passed!")
    print_info(f"Ready to import: sudo catalogctl import {yaml_file}")


def cmd_import(args):
    """Import container definition to catalog"""
    ensure_root()

    if not args.file:
        print_error("Usage: catalogctl import <file.yaml>")
        sys.exit(1)

    yaml_file = Path(args.file)
    if not yaml_file.exists():
        print_error(f"File not found: {yaml_file}")
        sys.exit(1)

    manager = CatalogManager()

    # Load container definition
    container_def = load_yaml(yaml_file)
    if not container_def:
        print_error("Invalid YAML syntax")
        sys.exit(1)

    container_id = container_def.get('id')
    if not container_id:
        print_error("Container definition missing 'id' field")
        sys.exit(1)

    print_header(f"Importing {container_id}")

    # Validate
    print_step("Validating")
    errors, warnings = manager.validate_container_def(container_def, yaml_file)
    if errors:
        print_fail()
        print()
        for error in errors:
            print_error(error)
        sys.exit(1)
    print_done()

    # Check conflicts
    print_step("Checking port conflicts")
    conflicts = manager.check_port_conflicts(container_def)
    if conflicts:
        print_fail()
        print()
        for conflict in conflicts:
            print_error(f"Port {conflict['port']}/{conflict['protocol']} already used by {conflict['container']}")
        sys.exit(1)
    print_done()

    # Check dependencies
    missing_deps = manager.check_dependencies(container_def)
    if missing_deps:
        print()
        print_warning("Missing dependencies:")
        for dep in missing_deps:
            print(f"  - {dep}")
        response = input("\nContinue anyway? [y/N]: ").strip().lower()
        if response not in ['y', 'yes']:
            print("Import cancelled.")
            sys.exit(0)

    # Copy to catalog
    print_step(f"Copying to {manager.containers_dir}/{container_id}.yaml")
    dest_file = manager.containers_dir / f"{container_id}.yaml"
    shutil.copy(yaml_file, dest_file)
    print_done()

    # Update catalog.yaml
    print_step("Updating catalog.yaml")
    catalog = manager.load_catalog()

    # Check if already exists
    existing_idx = None
    for i, c in enumerate(catalog['containers']):
        if c['id'] == container_id:
            existing_idx = i
            break

    # Build catalog entry
    catalog_entry = {
        'id': container_id,
        'name': container_def['name'],
        'category': container_def.get('category', 'infrastructure'),
        'description': container_def['description'],
        'version': container_def['version'],
        'url': f"containers/{container_id}.yaml"
    }

    # Optional fields
    if container_def.get('required'):
        catalog_entry['required'] = True
    if container_def.get('recommended'):
        catalog_entry['recommended'] = True
    if container_def.get('depends_on'):
        catalog_entry['depends_on'] = container_def['depends_on']
    if container_def.get('warnings'):
        catalog_entry['warnings'] = container_def['warnings']
    if container_def.get('tags'):
        catalog_entry['tags'] = container_def['tags']

    # Add or update
    if existing_idx is not None:
        catalog['containers'][existing_idx] = catalog_entry
    else:
        catalog['containers'].append(catalog_entry)

    manager.save_catalog(catalog)
    print_done()

    # Set permissions
    print_step("Setting permissions")
    subprocess.run(['chown', 'www-data:www-data', str(dest_file)], check=False)
    subprocess.run(['chown', 'www-data:www-data', str(manager.catalog_file)], check=False)
    print_done()

    print_success(f"{container_id} imported successfully!")
    print()
    print_info(f"Container: {container_def['name']}")
    print_info(f"Category: {container_def.get('category', 'infrastructure')}")
    print_info(f"Version: {container_def['version']}")
    print()
    print(f"üì¶ View catalog: catalogctl list")


def cmd_remove(args):
    """Remove container from catalog"""
    ensure_root()

    if not args.container:
        print_error("Usage: catalogctl remove <container>")
        sys.exit(1)

    container_id = args.container
    manager = CatalogManager()

    catalog = manager.load_catalog()

    # Find container
    found = False
    for c in catalog['containers']:
        if c['id'] == container_id:
            found = True
            break

    if not found:
        print_error(f"Container '{container_id}' not found in catalog")
        sys.exit(1)

    print_header(f"Removing {container_id}")

    # Confirm
    response = input("Are you sure? [y/N]: ").strip().lower()
    if response not in ['y', 'yes']:
        print("Removal cancelled.")
        sys.exit(0)

    # Remove from catalog.yaml
    print_step("Updating catalog.yaml")
    catalog['containers'] = [c for c in catalog['containers'] if c['id'] != container_id]
    manager.save_catalog(catalog)
    print_done()

    # Remove YAML file
    yaml_file = manager.containers_dir / f"{container_id}.yaml"
    if yaml_file.exists():
        if not args.keep_file:
            response = input(f"Delete {yaml_file}? [y/N]: ").strip().lower()
            if response in ['y', 'yes']:
                print_step(f"Deleting {yaml_file}")
                yaml_file.unlink()
                print_done()

    print_success(f"{container_id} removed from catalog!")


def cmd_list(args):
    """List all containers in catalog"""
    manager = CatalogManager()
    catalog = manager.load_catalog()

    print_header("Container Catalog")

    if not catalog.get('containers'):
        print("No containers in catalog.")
        print_info("Import container: sudo catalogctl import <file.yaml>")
        return

    # Group by category
    categories = {cat['id']: cat for cat in catalog['categories']}

    for cat_id, cat_info in categories.items():
        icon = cat_info.get('icon', 'üì¶')
        containers_in_cat = [c for c in catalog['containers'] if c.get('category') == cat_id]

        if not containers_in_cat:
            continue

        print(f"\n{icon} {cat_info['name']}:")
        for container in containers_in_cat:
            name = container['name']
            version = container['version']
            desc = container['description']
            print(f"  {container['id']:<20} v{version:<6} {desc}")

    print(f"\nTotal: {len(catalog['containers'])} containers")
    print(f"Updated: {catalog.get('updated', 'Unknown')}")


def cmd_export(args):
    """Export container definition"""
    if not args.container:
        print_error("Usage: catalogctl export <container>")
        sys.exit(1)

    container_id = args.container
    manager = CatalogManager()

    yaml_file = manager.containers_dir / f"{container_id}.yaml"
    if not yaml_file.exists():
        print_error(f"Container '{container_id}' not found")
        sys.exit(1)

    # Print to stdout
    with open(yaml_file, 'r') as f:
        print(f.read())


# ============================================================================
# CLI
# ============================================================================

def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description=f"catalogctl {VERSION} - Container Catalog Management",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # install
    parser_install = subparsers.add_parser('install', help='Install catalogctl')

    # validate
    parser_validate = subparsers.add_parser('validate', help='Validate container definition')
    parser_validate.add_argument('file', help='YAML file to validate')

    # import
    parser_import = subparsers.add_parser('import', help='Import container to catalog')
    parser_import.add_argument('file', help='YAML file to import')

    # remove
    parser_remove = subparsers.add_parser('remove', help='Remove container from catalog')
    parser_remove.add_argument('container', help='Container ID')
    parser_remove.add_argument('--keep-file', action='store_true', help='Keep YAML file')

    # list
    parser_list = subparsers.add_parser('list', help='List catalog containers')

    # export
    parser_export = subparsers.add_parser('export', help='Export container definition')
    parser_export.add_argument('container', help='Container ID')

    # version
    parser_version = subparsers.add_parser('version', help='Show version')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    # Route to command
    if args.command == 'install':
        cmd_install(args)
    elif args.command == 'validate':
        cmd_validate(args)
    elif args.command == 'import':
        cmd_import(args)
    elif args.command == 'remove':
        cmd_remove(args)
    elif args.command == 'list':
        cmd_list(args)
    elif args.command == 'export':
        cmd_export(args)
    elif args.command == 'version':
        print(f"catalogctl version {VERSION}")
    else:
        parser.print_help()


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nAborted by user.")
        sys.exit(130)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
