# gtwy - Tunnel Gateway Manager
## Technical Specification v1.0

---

## Overview

**gtwy** is a command-line tool for managing SSH reverse tunnels from remote IT.Boxes to a central nginx gateway server. It handles tunnel registration, nginx configuration, DNS updates, and SSL certificate management through a unified interface.

**Key Design Principles:**
- Single Python script (~600-800 lines)
- SQLite for state management
- Minimal file system footprint
- Intuitive command structure
- Robust error handling
- Suitable for 4-100 boxes

---

## Installation & File Structure

### Directory Layout
```
/opt/tunnel-gateway/
├── gtwy                    # Main executable (Python 3.8+)
├── config.yml             # Configuration file
├── tunnels.db             # SQLite database
├── nginx-template         # Template for nginx server blocks
└── gtwy.log               # Log file (rotating)

/etc/nginx/sites-enabled/
└── tunnels-autogen.conf   # Auto-generated by gtwy, DO NOT EDIT MANUALLY

/home/tunneluser/.ssh/
└── authorized_keys        # Managed by gtwy add-box/remove-box
```

### Permissions
```bash
/opt/tunnel-gateway/gtwy           # root:root, 755
/opt/tunnel-gateway/config.yml     # root:tunnel-admin, 640
/opt/tunnel-gateway/tunnels.db     # tunneluser:tunnel-admin, 664
/opt/tunnel-gateway/nginx-template # root:root, 644
/opt/tunnel-gateway/gtwy.log       # tunneluser:tunnel-admin, 664
```

### Sudo Configuration
```bash
# /etc/sudoers.d/tunnel-gateway
tunneluser ALL=(root) NOPASSWD: /usr/sbin/nginx -t
tunneluser ALL=(root) NOPASSWD: /usr/sbin/nginx -s reload
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot certonly *
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot delete --cert-name *
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot certificates
```

---

## Configuration File

### config.yml
```yaml
# Domain configuration
# Note: Domains are now assigned per-box, not globally
# This section lists available domains for validation (optional)
domains:
  - kibox.online
  - itbox.niedersachsen.de
  - private.example.com
  # Leave empty [] to allow any domain

# Port range for tunnel allocation
port_range:
  start: 10000
  end: 19999

# IONOS API credentials (for DNS management)
ionos:
  api_key: "your-ionos-api-key-here"
  # Optional: specific DNS zone if different from domain
  # zone: kibox.online

# Limits
max_tunnels_per_box: 10

# Paths
nginx:
  config_path: /etc/nginx/sites-enabled/tunnels-autogen.conf
  template_path: /opt/tunnel-gateway/nginx-template

ssh:
  authorized_keys_path: /home/tunneluser/.ssh/authorized_keys

certbot:
  email: admin@kibox.online
  staging: false  # Set to true for testing

# Logging
logging:
  level: INFO  # DEBUG, INFO, WARNING, ERROR
  file: /opt/tunnel-gateway/gtwy.log
  max_size_mb: 10
  backup_count: 5
```

---

## Database Schema

### SQLite Schema (tunnels.db)
```sql
-- Registered boxes
CREATE TABLE boxes (
    box_id TEXT PRIMARY KEY,
    domain TEXT NOT NULL,                     -- Domain for this box (e.g., 'kibox.online')
    ssh_key_type TEXT NOT NULL,              -- e.g., 'ssh-ed25519', 'ssh-rsa'
    ssh_key_fingerprint TEXT NOT NULL,       -- SHA256 fingerprint
    ssh_public_key TEXT NOT NULL,            -- Full public key
    added_date TEXT NOT NULL,                -- ISO 8601 timestamp
    last_seen TEXT,                          -- ISO 8601 timestamp (updated on request)
    notes TEXT                               -- Optional admin notes
);

-- Active tunnels
CREATE TABLE tunnels (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    box_id TEXT NOT NULL,
    service TEXT NOT NULL,                -- Service name (e.g., 'gitea', 'theia')
    local_port INTEGER NOT NULL,          -- Port on the box (e.g., 3000)
    server_port INTEGER UNIQUE NOT NULL,  -- Port on gateway server (e.g., 10001)
    subdomain TEXT UNIQUE NOT NULL,       -- Full subdomain (e.g., 'gitea.box01.kibox.online')
    status TEXT DEFAULT 'active',         -- 'active', 'pending_cert', 'error'
    created TEXT NOT NULL,                -- ISO 8601 timestamp
    last_checked TEXT,                    -- Last status check timestamp
    error_message TEXT,                   -- Error details if status='error'
    FOREIGN KEY (box_id) REFERENCES boxes(box_id) ON DELETE CASCADE,
    UNIQUE(box_id, service)
);

-- Indexes for performance
CREATE INDEX idx_tunnels_box_id ON tunnels(box_id);
CREATE INDEX idx_tunnels_subdomain ON tunnels(subdomain);
CREATE INDEX idx_tunnels_server_port ON tunnels(server_port);
CREATE INDEX idx_tunnels_status ON tunnels(status);
```

---

## nginx Template

### nginx-template
```nginx
# Template for a single tunnel server block
# Variables to replace: {SUBDOMAIN}, {SERVER_PORT}

server {
    listen 80;
    listen [::]:80;
    server_name {SUBDOMAIN};
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {SUBDOMAIN};
    
    # SSL certificates (managed by certbot)
    ssl_certificate /etc/letsencrypt/live/{SUBDOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{SUBDOMAIN}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    # Proxy settings
    location / {
        proxy_pass http://localhost:{SERVER_PORT};
        proxy_http_version 1.1;
        
        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Standard proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts (adjust as needed)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Optional: Increase upload size for file uploads
    client_max_body_size 100M;
}
```

---

## Command Reference

### Global Flags
```
-v, --verbose       Detailed output
-q, --quiet         Only show errors
--json              JSON output for scripting
--dry-run           Show what would happen without executing
-y, --yes           Skip confirmation prompts
-h, --help          Show help message
```

### Exit Codes
- `0` - Success
- `1` - General error
- `2` - Validation error (invalid input)
- `3` - Permission denied
- `4` - Resource not found
- `5` - Dependency error (nginx, certbot, etc.)

---

## Commands Specification

### 1. add-box

**Purpose:** Register a new box with its SSH public key and assigned domain

**Syntax:**
```bash
gtwy add-box <box-id> <domain> <public-key-source> [options]
```

**Arguments:**
- `box-id`: Unique identifier for the box (regex: `^[a-z0-9-]+$`)
- `domain`: Domain to use for this box's tunnels (e.g., `kibox.online`)
- `public-key-source`: Either:
  - Path to public key file (e.g., `/tmp/box01_key.pub`)
  - Direct key string (e.g., `"ssh-ed25519 AAAAC3..."`)

**Options:**
- `--notes "text"`: Optional admin notes about this box

**Behavior:**
1. Validate box-id format
2. Validate domain (check against allowed domains list if configured)
3. Parse public key (extract type, fingerprint, full key)
4. Check if box-id already exists (error if yes)
5. Insert into `boxes` table with domain
6. Generate authorized_keys entry:
   ```
   command="BOX_ID=<box-id> /opt/tunnel-gateway/gtwy request",restrict,port-forwarding <public-key>
   ```
7. Append to `/home/tunneluser/.ssh/authorized_keys`

**Output:**
```
✓ Box <box-id> added successfully
  Domain:       <domain>
  SSH Key Type: <type>
  Fingerprint:  <fingerprint>
  
Tunnels for this box will use: <service>.<box-id>.<domain>
Test connection: ssh tunneluser@<server-ip>
```

**Errors:**
- Box-id already exists
- Invalid box-id format
- Invalid or disallowed domain
- Invalid public key format
- Permission denied (not running as root/sudo)

**Examples:**
```bash
# Add box with kibox.online domain
sudo gtwy add-box box01 kibox.online /tmp/box01_key.pub

# Add box with different domain (private deployment)
sudo gtwy add-box mybox private.example.com "ssh-ed25519 AAAAC3..."

# With notes
sudo gtwy add-box school-abc itbox.niedersachsen.de ~/.ssh/abc_key.pub --notes "Test school ABC"
```

---

### 2. remove-box

**Purpose:** Remove a box and all its tunnels

**Syntax:**
```bash
gtwy remove-box <box-id> [options]
```

**Arguments:**
- `box-id`: ID of the box to remove

**Options:**
- `-y, --yes`: Skip confirmation prompt

**Behavior:**
1. Check if box exists
2. Find all tunnels for this box
3. Show warning with list of tunnels to be removed
4. Prompt for confirmation (unless `-y`)
5. For each tunnel:
   - Remove from nginx config
   - Remove DNS entry
   - Revoke certificate
   - Delete from DB
6. Remove box from `boxes` table
7. Remove from authorized_keys

**Output:**
```
Warning: This will remove all tunnels for box <box-id>:
  - <service1>.<box-id>.<domain>
  - <service2>.<box-id>.<domain>
Continue? [y/N] y

Removing box <box-id>...
  - Removing 2 tunnels... ✓
  - Cleaning up nginx config... ✓
  - Removing DNS entries... ✓
  - Revoking certificates... ✓
  - Removing from authorized_keys... ✓

Box <box-id> removed successfully
```

---

### 3. list-boxes

**Purpose:** Show all registered boxes

**Syntax:**
```bash
gtwy list-boxes [options]
```

**Options:**
- `--json`: Output as JSON

**Output (table):**
```
Registered Boxes:
  box01     kibox.online              (ssh-ed25519:a3:f2:..., added 2025-01-10, last seen 2h ago)
  box02     itbox.niedersachsen.de    (ssh-rsa:b1:4c:..., added 2025-01-12, never seen)
  mybox     private.example.com       (ssh-ed25519:c9:1a:..., added 2025-01-15, last seen 5m ago)
  
Total: 3 boxes across 3 domains
```

**Output (JSON):**
```json
{
  "boxes": [
    {
      "box_id": "box01",
      "domain": "kibox.online",
      "ssh_key_type": "ssh-ed25519",
      "ssh_key_fingerprint": "SHA256:a3f2...",
      "added_date": "2025-01-10T14:23:11Z",
      "last_seen": "2025-01-15T10:15:32Z",
      "tunnel_count": 3
    }
  ],
  "total": 3
}
```

---

### 4. request

**Purpose:** Request a new tunnel (called by box via SSH)

**Syntax:**
```bash
gtwy request <service> <local-port>
```

**Environment Variables Required:**
- `BOX_ID`: Set by authorized_keys command restriction

**Arguments:**
- `service`: Service name (regex: `^[a-z0-9-]+$`)
- `local-port`: Local port on box (1-65535)

**Behavior:**
1. Read `BOX_ID` from environment
2. Validate service name and port
3. Check if box exists in DB and retrieve its assigned domain
4. Check tunnel limit for box (max_tunnels_per_box)
5. Build subdomain: `<service>.<box-id>.<box-domain>`
6. Check if subdomain already exists (error if yes)
7. Allocate free server port (lowest available in range)
8. Begin database transaction
9. Insert tunnel into DB with status='active'
10. Generate nginx server block from template
11. Append to `/etc/nginx/sites-enabled/tunnels-autogen.conf`
12. Test nginx config (`nginx -t`)
13. Reload nginx (`nginx -s reload`)
14. Create DNS A record via IONOS API (using box's domain/zone)
15. Mark for certificate generation (status='pending_cert' if DNS not ready)
16. Commit database transaction
17. Update box.last_seen
18. Print server port to stdout
19. Log operation

**Output (stdout only):**
```
10001
```

**Logging:**
```
[2025-01-15 14:23:45] INFO: Tunnel requested by box01 (domain: kibox.online): gitea.box01.kibox.online
[2025-01-15 14:23:45] INFO: Allocated port 10001
[2025-01-15 14:23:46] INFO: nginx reloaded successfully
[2025-01-15 14:23:47] INFO: DNS record created for gitea.box01.kibox.online
[2025-01-15 14:23:47] INFO: Tunnel active: gitea.box01.kibox.online → 10001
```

**Errors:**
- BOX_ID not set (not called via authorized_keys)
- Box not registered
- Invalid service name or port
- Tunnel already exists for this box/service
- No free ports available
- nginx configuration test failed
- DNS API error
- Database transaction failed

---

### 5. release

**Purpose:** Release a tunnel (called by box via SSH)

**Syntax:**
```bash
gtwy release <service>
```

**Environment Variables Required:**
- `BOX_ID`: Set by authorized_keys command restriction

**Arguments:**
- `service`: Service name to release

**Behavior:**
1. Read `BOX_ID` from environment
2. Find tunnel by box_id + service
3. Remove from nginx config
4. Test and reload nginx
5. Remove DNS entry
6. Revoke certificate (if exists)
7. Delete from DB
8. Log operation

**Output:**
```
✓ Tunnel <service> released
```

---

### 6. list

**Purpose:** Show all active tunnels

**Syntax:**
```bash
gtwy list [options]
```

**Options:**
- `--box <box-id>`: Filter by box
- `--status <status>`: Filter by status (active, pending_cert, error)
- `--json`: Output as JSON

**Output (table):**
```
Active Tunnels:
┌─────────────────────────────────┬───────┬─────────┬───────┬───────┬──────────┬─────────┐
│ Subdomain                       │ Box   │ Service │ Local │ Server│ Status   │ Age     │
├─────────────────────────────────┼───────┼─────────┼───────┼───────┼──────────┼─────────┤
│ gitea.box01.kibox.online       │ box01 │ gitea   │  3000 │ 10001 │ active   │ 3d 2h   │
│ theia.box01.kibox.online       │ box01 │ theia   │  3000 │ 10002 │ active   │ 3d 2h   │
│ portainer.box01.kibox.online   │ box01 │ port    │  9000 │ 10003 │ active   │ 3d 2h   │
│ gitea.box02.kibox.online       │ box02 │ gitea   │  3000 │ 10011 │ pending  │ 1h 23m  │
└─────────────────────────────────┴───────┴─────────┴───────┴───────┴──────────┴─────────┘

Total: 4 tunnels (3 active, 1 pending)
```

---

### 7. info

**Purpose:** Show detailed information about a tunnel

**Syntax:**
```bash
gtwy info <subdomain>
```

**Arguments:**
- `subdomain`: Full subdomain (e.g., `gitea.box01.kibox.online`)

**Behavior:**
1. Find tunnel in DB
2. Check nginx config exists
3. Check DNS record exists
4. Check certificate status
5. Check if port is listening (optional)

**Output:**
```
Tunnel Details:
  Subdomain:    gitea.box01.kibox.online
  Box ID:       box01
  Service:      gitea
  Local Port:   3000
  Server Port:  10001
  Status:       active
  Created:      2025-01-12 14:23:11
  Last Checked: 2025-01-15 10:30:00
  
  nginx:        ✓ configured
  DNS:          ✓ configured (A record → <server-ip>)
  Certificate:  ✓ valid until 2025-04-12
  Connection:   ✓ port 10001 listening
```

---

### 8. remove

**Purpose:** Manually remove a tunnel (admin operation)

**Syntax:**
```bash
gtwy remove <subdomain> [options]
```

**Arguments:**
- `subdomain`: Full subdomain to remove

**Options:**
- `-y, --yes`: Skip confirmation

**Behavior:**
Same as `release` but works with subdomain instead of service name, and doesn't require BOX_ID.

---

### 9. status

**Purpose:** Check health of all tunnels

**Syntax:**
```bash
gtwy status [options]
```

**Options:**
- `--box <box-id>`: Check only tunnels for specific box
- `--fix`: Attempt to fix issues automatically

**Behavior:**
1. For each tunnel:
   - Check if server port is listening (netstat/ss)
   - Update last_checked timestamp
   - Update status if changed
2. Report healthy/unhealthy tunnels

**Output:**
```
Checking tunnel status...
  ✓ gitea.box01.kibox.online (port 10001 responding)
  ✓ theia.box01.kibox.online (port 10002 responding)
  ✓ portainer.box01.kibox.online (port 10003 responding)
  ✗ gitea.box02.kibox.online (port 10011 not responding)
  
3/4 tunnels healthy
Warning: 1 tunnel appears offline
```

---

### 10. stats

**Purpose:** Show gateway statistics

**Syntax:**
```bash
gtwy stats
```

**Output:**
```
Gateway Statistics:
  Registered Boxes:     3
  Domains in use:       2 (kibox.online, private.example.com)
  Active Tunnels:       4
  Pending Tunnels:      1
  Error Tunnels:        0
  Used Ports:           10001-10003, 10011
  Available Ports:      9995
  Port Range:           10000-19999
  Port Utilization:     0.05%
  Oldest Tunnel:        3d 2h (gitea.box01.kibox.online)
  Newest Tunnel:        1h 23m (gitea.box02.kibox.online)
```

---

### 11. sync-nginx

**Purpose:** Regenerate nginx configuration from database

**Syntax:**
```bash
gtwy sync-nginx
```

**Behavior:**
1. Query all tunnels from DB
2. Generate complete nginx config from template
3. Write to temp file
4. Test nginx config
5. Move to production location
6. Reload nginx

**Use Case:** Recovery after manual nginx config corruption

---

### 12. sync-dns

**Purpose:** Synchronize DNS records with database state

**Syntax:**
```bash
gtwy sync-dns [options]
```

**Options:**
- `--dry-run`: Show what would be done

**Behavior:**
1. Query all tunnels from DB
2. Query existing DNS records from IONOS
3. Compare and identify:
   - Missing DNS entries (in DB but not in DNS)
   - Orphaned DNS entries (in DNS but not in DB)
4. Create missing entries
5. Optionally remove orphaned entries (with confirmation)

---

### 13. sync-certs

**Purpose:** Request certificates for tunnels with pending_cert status

**Syntax:**
```bash
gtwy sync-certs
```

**Behavior:**
1. Find all tunnels with status='pending_cert'
2. For each:
   - Check if DNS has propagated
   - Request certificate via certbot
   - Update status to 'active' on success
   - Update error_message on failure

---

### 14. cleanup

**Purpose:** Clean up orphaned resources

**Syntax:**
```bash
gtwy cleanup [options]
```

**Options:**
- `--dry-run`: Show what would be cleaned up
- `-y, --yes`: Skip confirmations

**Behavior:**
1. Check for orphaned nginx configs
2. Check for orphaned DNS entries
3. Check for unused certificates
4. Report and optionally remove

---

### 15. rebuild

**Purpose:** Completely rebuild all configurations from database

**Syntax:**
```bash
gtwy rebuild
```

**Behavior:**
1. Regenerate nginx config
2. Synchronize DNS
3. Request missing certificates
4. Report results

**Use Case:** Major recovery operation

---

## Implementation Details

### Port Allocation Algorithm

```python
def allocate_port():
    """Find the lowest available port in the configured range."""
    used_ports = db.execute(
        "SELECT server_port FROM tunnels ORDER BY server_port"
    ).fetchall()
    
    used_ports_set = {row[0] for row in used_ports}
    
    for port in range(config['port_range']['start'], config['port_range']['end'] + 1):
        if port not in used_ports_set:
            return port
    
    raise NoPortsAvailable("All ports in range are allocated")
```

### Subdomain Generation

```python
def generate_subdomain(service, box_id):
    """Generate subdomain following the pattern: service.box-id.box-domain"""
    # Get box's assigned domain from database
    box = db.execute("SELECT domain FROM boxes WHERE box_id = ?", (box_id,)).fetchone()
    if not box:
        raise NotFoundError(f"Box {box_id} not found")
    
    box_domain = box['domain']
    
    # Already validated at this point
    return f"{service}.{box_id}.{box_domain}"
```

### nginx Configuration Generation

```python
def generate_nginx_config():
    """Generate complete nginx configuration from database."""
    tunnels = db.execute("SELECT * FROM tunnels WHERE status != 'error'").fetchall()
    
    config_blocks = []
    for tunnel in tunnels:
        block = load_template()
        block = block.replace('{SUBDOMAIN}', tunnel['subdomain'])
        block = block.replace('{SERVER_PORT}', str(tunnel['server_port']))
        config_blocks.append(block)
    
    return "\n\n".join(config_blocks)
```

### DNS Management (IONOS API)

```python
def create_dns_record(subdomain):
    """Create A record via IONOS API.
    
    Subdomain format: service.box-id.domain (e.g., gitea.box01.kibox.online)
    We need to:
    1. Extract the domain from the subdomain
    2. Find the corresponding IONOS zone
    3. Create the record with the hostname part
    """
    # Extract domain from subdomain
    # e.g., gitea.box01.kibox.online → domain is kibox.online
    parts = subdomain.split('.')
    if len(parts) < 3:
        raise ValueError(f"Invalid subdomain format: {subdomain}")
    
    # Last two parts are typically the domain (adjust for country codes like .co.uk)
    domain = '.'.join(parts[-2:])
    
    # Hostname is everything before the domain
    # e.g., gitea.box01.kibox.online → hostname is gitea.box01
    hostname = subdomain.replace(f".{domain}", "")
    
    # Get zone ID for this domain (IONOS API requires zone ID)
    zone_id = get_zone_id_for_domain(domain)
    
    api_url = f"https://api.hosting.ionos.com/dns/v1/zones/{zone_id}/records"
    headers = {
        "X-API-Key": config['ionos']['api_key']
    }
    
    payload = {
        "name": hostname,
        "type": "A",
        "content": get_server_public_ip(),
        "ttl": 3600,
        "disabled": False
    }
    
    response = requests.post(api_url, headers=headers, json=payload)
    response.raise_for_status()

def get_zone_id_for_domain(domain):
    """Get IONOS zone ID for a given domain.
    
    IONOS zones can be listed via API:
    GET https://api.hosting.ionos.com/dns/v1/zones
    
    Returns the zone ID or raises error if domain not managed by IONOS.
    """
    api_url = "https://api.hosting.ionos.com/dns/v1/zones"
    headers = {
        "X-API-Key": config['ionos']['api_key']
    }
    
    response = requests.get(api_url, headers=headers)
    response.raise_for_status()
    zones = response.json()
    
    for zone in zones:
        if zone['name'] == domain:
            return zone['id']
    
    raise NotFoundError(f"Domain {domain} not found in IONOS account. "
                       f"Available domains: {[z['name'] for z in zones]}")

def delete_dns_record(subdomain):
    """Delete A record via IONOS API."""
    parts = subdomain.split('.')
    domain = '.'.join(parts[-2:])
    hostname = subdomain.replace(f".{domain}", "")
    
    zone_id = get_zone_id_for_domain(domain)
    
    # Get record ID first
    api_url = f"https://api.hosting.ionos.com/dns/v1/zones/{zone_id}/records"
    headers = {"X-API-Key": config['ionos']['api_key']}
    
    response = requests.get(api_url, headers=headers)
    response.raise_for_status()
    records = response.json()
    
    # Find matching record
    record_id = None
    for record in records:
        if record['name'] == hostname and record['type'] == 'A':
            record_id = record['id']
            break
    
    if not record_id:
        raise NotFoundError(f"DNS record for {subdomain} not found")
    
    # Delete record
    delete_url = f"{api_url}/{record_id}"
    response = requests.delete(delete_url, headers=headers)
    response.raise_for_status()
```

### Certificate Management

```python
def request_certificate(subdomain):
    """Request Let's Encrypt certificate via certbot."""
    cmd = [
        "sudo", "certbot", "certonly",
        "--nginx",
        "-d", subdomain,
        "--non-interactive",
        "--agree-tos",
        "--email", config['certbot']['email']
    ]
    
    if config['certbot']['staging']:
        cmd.append("--staging")
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise CertbotError(f"Certificate request failed: {result.stderr}")
```

### authorized_keys Management

```python
def add_to_authorized_keys(box_id, public_key):
    """Add box to authorized_keys with command restriction."""
    entry = (
        f'command="BOX_ID={box_id} /opt/tunnel-gateway/gtwy request",'
        f'restrict,port-forwarding {public_key}\n'
    )
    
    auth_keys_path = config['ssh']['authorized_keys_path']
    
    with open(auth_keys_path, 'a') as f:
        f.write(entry)
```

### Error Handling Strategy

```python
class GatewayError(Exception):
    """Base exception for gateway errors."""
    pass

class ValidationError(GatewayError):
    """Input validation failed."""
    exit_code = 2

class PermissionError(GatewayError):
    """Insufficient permissions."""
    exit_code = 3

class NotFoundError(GatewayError):
    """Resource not found."""
    exit_code = 4

class DependencyError(GatewayError):
    """External dependency failed (nginx, certbot, etc.)."""
    exit_code = 5

def main():
    try:
        # Parse args and execute command
        execute_command()
    except ValidationError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(2)
    except PermissionError as e:
        print(f"Permission denied: {e}", file=sys.stderr)
        sys.exit(3)
    except NotFoundError as e:
        print(f"Not found: {e}", file=sys.stderr)
        sys.exit(4)
    except DependencyError as e:
        print(f"Dependency error: {e}", file=sys.stderr)
        sys.exit(5)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        logging.exception("Unexpected error")
        sys.exit(1)
```

### Logging Configuration

```python
import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """Configure logging with rotation."""
    log_config = config['logging']
    
    handler = RotatingFileHandler(
        log_config['file'],
        maxBytes=log_config['max_size_mb'] * 1024 * 1024,
        backupCount=log_config['backup_count']
    )
    
    formatter = logging.Formatter(
        '[%(asctime)s] %(levelname)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    logger = logging.getLogger('gtwy')
    logger.addHandler(handler)
    logger.setLevel(getattr(logging, log_config['level']))
    
    return logger
```

### Validation Functions

```python
import re

def validate_box_id(box_id):
    """Validate box ID format."""
    if not re.match(r'^[a-z0-9-]+$', box_id):
        raise ValidationError(
            f"Invalid box-id '{box_id}'\n"
            "Box IDs must match: ^[a-z0-9-]+$ (lowercase, numbers, hyphens only)\n"
            "Example: box01, test-box, school-abc"
        )

def validate_service_name(service):
    """Validate service name format."""
    if not re.match(r'^[a-z0-9-]+$', service):
        raise ValidationError(
            f"Invalid service name '{service}'\n"
            "Service names must match: ^[a-z0-9-]+$"
        )

def validate_port(port):
    """Validate port number."""
    try:
        port = int(port)
        if not (1 <= port <= 65535):
            raise ValueError
    except ValueError:
        raise ValidationError(f"Invalid port: {port}. Must be 1-65535")
    return port

def validate_domain(domain):
    """Validate domain format and check against allowed list if configured."""
    # Basic domain format validation
    domain_regex = r'^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
    if not re.match(domain_regex, domain.lower()):
        raise ValidationError(
            f"Invalid domain format: {domain}\n"
            "Domains must be valid FQDN (e.g., example.com, sub.example.org)"
        )
    
    # Check against allowed domains list if configured
    allowed_domains = config.get('domains', [])
    if allowed_domains and domain not in allowed_domains:
        raise ValidationError(
            f"Domain '{domain}' is not in the allowed list.\n"
            f"Allowed domains: {', '.join(allowed_domains)}\n"
            "Update config.yml to add more domains or leave domains list empty to allow any."
        )
    
    return domain

def validate_ssh_key(key_string):
    """Validate SSH public key format."""
    parts = key_string.strip().split()
    if len(parts) < 2:
        raise ValidationError("Invalid SSH key format")
    
    key_type = parts[0]
    if key_type not in ['ssh-rsa', 'ssh-ed25519', 'ssh-dss', 'ecdsa-sha2-nistp256']:
        raise ValidationError(f"Unsupported key type: {key_type}")
    
    # Base64 validation
    try:
        import base64
        base64.b64decode(parts[1])
    except Exception:
        raise ValidationError("Invalid base64 encoding in SSH key")
    
    return key_type, parts[1]
```

---

## Installation Script

```bash
#!/bin/bash
# install-gtwy.sh - Install Tunnel Gateway Manager

set -e

echo "Installing Tunnel Gateway Manager..."

# Check prerequisites
command -v python3 >/dev/null || { echo "Error: python3 not found"; exit 1; }
command -v nginx >/dev/null || { echo "Error: nginx not found"; exit 1; }
command -v certbot >/dev/null || { echo "Error: certbot not found"; exit 1; }

# Create directory
mkdir -p /opt/tunnel-gateway
cd /opt/tunnel-gateway

# Create config template
cat > config.yml <<EOF
# List of allowed domains (leave empty to allow any domain)
domains:
  - kibox.online
  - itbox.niedersachsen.de
  # Add more domains as needed, or set to [] to allow any

port_range:
  start: 10000
  end: 19999
ionos:
  api_key: "YOUR_API_KEY_HERE"
max_tunnels_per_box: 10
nginx:
  config_path: /etc/nginx/sites-enabled/tunnels-autogen.conf
  template_path: /opt/tunnel-gateway/nginx-template
ssh:
  authorized_keys_path: /home/tunneluser/.ssh/authorized_keys
certbot:
  email: admin@kibox.online
  staging: false
logging:
  level: INFO
  file: /opt/tunnel-gateway/gtwy.log
  max_size_mb: 10
  backup_count: 5
EOF

# Create nginx template
cat > nginx-template <<'EOF'
server {
    listen 80;
    listen [::]:80;
    server_name {SUBDOMAIN};
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {SUBDOMAIN};
    
    ssl_certificate /etc/letsencrypt/live/{SUBDOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{SUBDOMAIN}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    location / {
        proxy_pass http://localhost:{SERVER_PORT};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    client_max_body_size 100M;
}
EOF

# Create group and set permissions
groupadd -f tunnel-admin
usermod -aG tunnel-admin tunneluser

chown root:root /opt/tunnel-gateway/gtwy
chmod 755 /opt/tunnel-gateway/gtwy
chown root:tunnel-admin /opt/tunnel-gateway/config.yml
chmod 640 /opt/tunnel-gateway/config.yml
chown root:root /opt/tunnel-gateway/nginx-template
chmod 644 /opt/tunnel-gateway/nginx-template

# Create sudo config
cat > /etc/sudoers.d/tunnel-gateway <<EOF
tunneluser ALL=(root) NOPASSWD: /usr/sbin/nginx -t
tunneluser ALL=(root) NOPASSWD: /usr/sbin/nginx -s reload
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot certonly *
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot delete --cert-name *
tunneluser ALL=(root) NOPASSWD: /usr/bin/certbot certificates
EOF
chmod 440 /etc/sudoers.d/tunnel-gateway

# Create symlink
ln -sf /opt/tunnel-gateway/gtwy /usr/local/bin/gtwy

# Initialize database
/opt/tunnel-gateway/gtwy --init-db

echo "✓ Installation complete!"
echo "Edit /opt/tunnel-gateway/config.yml to configure your domain and IONOS API key"
```

---

## Testing Strategy

### Unit Tests
- Validation functions
- Port allocation algorithm
- Subdomain generation
- Configuration parsing

### Integration Tests
- Database operations
- nginx config generation
- SSH key parsing
- authorized_keys management

### End-to-End Tests
1. Add box → Verify authorized_keys
2. Request tunnel → Verify DB, nginx, DNS
3. Release tunnel → Verify cleanup
4. Remove box → Verify complete cleanup

---

## Dependencies

### Python Packages (requirements.txt)
```
pyyaml>=6.0
requests>=2.31.0
tabulate>=0.9.0
```

### System Requirements
- Python 3.8+
- nginx
- certbot
- sqlite3
- OpenSSH server
- curl (for IONOS API)

---

## Future Enhancements (Out of Scope for v1.0)

1. Web dashboard (Flask/FastAPI)
2. Prometheus metrics export
3. Automatic tunnel health monitoring with alerts
4. Multiple domain support
5. SSH Certificate Authority instead of individual keys
6. nginx Lua dynamic routing for very large deployments
7. Backup/restore functionality
8. Rate limiting per box
9. Webhook notifications
10. Multi-server support (HA setup)

---

## Security Considerations

1. **SSH Key Management:**
   - Keys are append-only to authorized_keys
   - Command restriction prevents arbitrary command execution
   - `restrict` flag disables shell access, port forwarding only

2. **File Permissions:**
   - config.yml contains API keys → group-readable only
   - gtwy script is root-owned → prevents tampering
   - Database is tunneluser-owned with group access

3. **Sudo Restrictions:**
   - Only specific nginx/certbot commands allowed
   - No shell execution possible
   - NOPASSWD only for non-interactive commands

4. **Input Validation:**
   - Strict regex for box-id and service names
   - SSH key format validation
   - Port range validation

5. **API Key Storage:**
   - IONOS API key in config.yml (not in code)
   - File permissions prevent unauthorized access

6. **Logging:**
   - All operations logged with timestamps
   - Failed operations logged with details
   - Rotating logs prevent disk space exhaustion

---

## DNS Zone Management

### Multiple Domains

gtwy supports multiple domains simultaneously. Each box is assigned a specific domain when registered with `add-box`. This allows you to:

- Use different domains for different deployment types (e.g., `kibox.online` for production, `test.kibox.online` for testing)
- Support multiple organizations on the same gateway (e.g., different schools with different domains)
- Mix public and private domains

### IONOS Requirements

**For multi-domain support:**
1. All domains must be managed in the same IONOS account (same API key)
2. Each domain must have its own DNS zone in IONOS
3. The API key must have permissions for all zones

**Checking available zones:**
```bash
curl -X GET "https://api.hosting.ionos.com/dns/v1/zones" \
  -H "X-API-Key: YOUR_API_KEY" | jq '.[] | {name: .name, id: .id}'
```

**Zone not found error:**
If gtwy reports "Domain X not found in IONOS account", ensure:
1. The domain is added to your IONOS account
2. DNS management is active for the domain
3. The API key has access to the zone

### Domain Validation

Configure allowed domains in `config.yml`:

```yaml
# Option 1: Restrict to specific domains (recommended)
domains:
  - kibox.online
  - itbox.niedersachsen.de
  - test-deployment.org

# Option 2: Allow any domain (less secure, use with caution)
domains: []
```

**Recommendation:** Always specify allowed domains explicitly to prevent accidental registration of wrong domains.

---

## Troubleshooting Guide

### Problem: "Domain not found in IONOS account"
**Causes:**
- Domain not added to IONOS account
- Wrong IONOS API key
- DNS zone not created in IONOS

**Solution:**
1. Login to IONOS control panel
2. Verify domain is in your account
3. Ensure DNS management is active
4. Check API key permissions
5. List zones: `curl -H "X-API-Key: KEY" https://api.hosting.ionos.com/dns/v1/zones`

### Problem: "Domain not in allowed list"
**Solution:**
- Add domain to `config.yml` under `domains:` list
- Or set `domains: []` to allow any domain (not recommended for production)

### Problem: Tunnel not accessible after creation
**Check:**
1. `gtwy info <subdomain>` - Check all components
2. DNS propagation: `dig <subdomain>`
3. Certificate: `sudo certbot certificates`
4. Port listening: `ss -tlnp | grep <port>`
5. nginx config: `sudo nginx -t`

### Problem: Certificate request fails
**Likely causes:**
- DNS not yet propagated (wait 5 minutes)
- Domain ownership not verified
- Rate limit hit (Let's Encrypt)

**Solution:**
- Wait for DNS: `gtwy sync-certs` (retries)
- Check DNS: `dig <subdomain>`
- Use staging for testing: Set `certbot.staging: true` in config

### Problem: No free ports available
**Solution:**
1. Check current allocation: `gtwy stats`
2. Expand port range in config.yml
3. Clean up old tunnels: `gtwy cleanup`

### Problem: Box cannot connect
**Check:**
1. SSH key in authorized_keys: `grep <box-id> /home/tunneluser/.ssh/authorized_keys`
2. Test SSH: `ssh tunneluser@server` (should show restriction message)
3. Check logs: `tail -f /opt/tunnel-gateway/gtwy.log`

---

## Maintenance Tasks

### Daily
- Monitor logs for errors
- Check tunnel health: `gtwy status`

### Weekly
- Review statistics: `gtwy stats`
- Check certificate expirations: `sudo certbot certificates`

### Monthly
- Audit box list: `gtwy list-boxes`
- Clean up orphaned resources: `gtwy cleanup`
- Review and rotate logs

### On-Demand
- Add new box: `gtwy add-box <id> <key>`
- Remove old box: `gtwy remove-box <id>`
- Manual tunnel removal: `gtwy remove <subdomain>`

---

## Complete Workflow Example

### Setup (One-time)
```bash
# On gateway server
sudo /opt/tunnel-gateway/install-gtwy.sh
sudo vim /opt/tunnel-gateway/config.yml  # Set domain, API key
```

### Add New Box
```bash
# Box generates key
ssh-keygen -t ed25519 -f ~/.ssh/tunnel_key -C "box04"

# Get public key to server (any method)
cat ~/.ssh/tunnel_key.pub
# Copy output

# On server - specify domain for this box
sudo gtwy add-box box04 kibox.online "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA..."

# Or for a different domain
sudo gtwy add-box mybox private.example.com "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA..."
```

### Box Requests Tunnel
```bash
# On box - request tunnel
PORT=$(ssh -i ~/.ssh/tunnel_key tunneluser@gateway.example.com "request gitea 3000")
echo "Assigned port: $PORT"

# Set up autossh
autossh -M 0 -f -N \
  -o "ServerAliveInterval=30" \
  -o "ServerAliveCountMax=3" \
  -i ~/.ssh/tunnel_key \
  -R $PORT:localhost:3000 \
  tunneluser@gateway.example.com
```

### Monitor
```bash
# On server
gtwy list
gtwy status
gtwy info gitea.box04.kibox.online
```

### Remove Tunnel
```bash
# From box
ssh -i ~/.ssh/tunnel_key tunneluser@gateway.example.com "release gitea"

# Or from server (admin)
sudo gtwy remove gitea.box04.kibox.online
```

---

## Appendix: Command Quick Reference

```
Box Management:
  add-box <id> <domain> <key>  Register new box with domain
  remove-box <id>              Remove box and tunnels
  list-boxes                   Show all boxes with domains

Tunnel Operations:
  request <service> <port>  Request new tunnel (from box)
  release <service>         Release tunnel (from box)
  remove <subdomain>        Remove tunnel (admin)
  list                      Show all tunnels
  info <subdomain>          Show tunnel details

Status & Diagnostics:
  status                    Check tunnel health
  stats                     Show statistics

Maintenance:
  sync-nginx                Rebuild nginx config
  sync-dns                  Sync DNS records
  sync-certs                Request pending certificates
  cleanup                   Clean orphaned resources
  rebuild                   Full rebuild from DB

Global Flags:
  -v, --verbose             Detailed output
  -q, --quiet               Only errors
  --json                    JSON output
  --dry-run                 Show without executing
  -y, --yes                 Skip confirmations
  -h, --help                Show help
```

---

**End of Specification**

This specification is designed to be implementation-ready. All commands, behaviors, error cases, and technical details are defined. Use this document as the blueprint for building the gtwy tool with Claude Code.